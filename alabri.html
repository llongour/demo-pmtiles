<!DOCTYPE html>
<html lang="fr">

<head>
  <title>Éligibilite au diagnostic ALABRI</title>
  <meta charset='utf-8'>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="assets/style.css">
  <script src='https://cdn.jsdelivr.net/npm/geotoolbox@2.0'></script>
  <script src='https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js'></script>
  <link rel='stylesheet' href='https://unpkg.com/maplibre-gl@4.3.2/dist/maplibre-gl.css' />
  <script src='https://unpkg.com/maplibre-gl@4.3.2/dist/maplibre-gl.js'></script>
  <script src="https://cdn.jsdelivr.net/npm/pmtiles@3.0.5/dist/pmtiles.js"></script>
  <script src="https://unpkg.com/@maplibre/maplibre-gl-geocoder@1.2.0/dist/maplibre-gl-geocoder.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/@maplibre/maplibre-gl-geocoder@1.2.0/dist/maplibre-gl-geocoder.css"
    type="text/css">
  <script src="assets/js/geocoderApi.js"></script>
  <script src="assets/js/sourcesAndLayers.js"></script>
  <script src="assets/js/odsUtils.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    html,
    body,
    #map {
      height: 100%;
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <script>
    // Configuration du protocole pour pmtiles
    const protocol = new pmtiles.Protocol();
    maplibregl.addProtocol("pmtiles", protocol.tile);

    const map = new maplibregl.Map({
      container: 'map',
      style: {
        'version': 8,
        'sources': {
          'raster-tiles': {
            'type': 'raster',
            'tiles': [
              'https://adict.strasbourg.eu/mapproxy/service?VERSION=1.1.0&1=2&SERVICE=WMS&REQUEST=GetMap&VERSION=1.1.1&LAYERS=monstrasbourg&STYLES=&FORMAT=image%2Fpng&TRANSPARENT=false&HEIGHT=256&WIDTH=256&SRS=EPSG%3A3857&BBOX={bbox-epsg-3857}'
            ],
            'tileSize': 256
          }
        },
        'layers': [
          {
            'id': 'simple-tiles',
            'type': 'raster',
            'source': 'raster-tiles',
            'minzoom': 0,
            'maxzoom': 22
          }
        ]
      },
      minZoom: 10,
      maxZoom: 16,
      center: [7.7254, 48.5798],
      hash: true,
      zoom: 13,
    });

    map.dragRotate.disable();

    map.addControl(
      new MaplibreGeocoder(geocoderApi, {
        maplibregl,
      })
    );

    map.addControl(
      new maplibregl.NavigationControl({
        visualizePitch: true,
        showZoom: true,
        showCompass: false
      })
    );

    map.addControl(
      new maplibregl.GeolocateControl({
        positionOptions: {
          enableHighAccuracy: true,
        },
        trackUserLocation: true,
      })
    );

    map.addControl(new maplibregl.FullscreenControl());
    map.addControl(new maplibregl.NavigationControl({ showCompass: false }));

    map.on("load", function () {
      addSources(map);
      addLayers(map);
    });

    // Gestion de l'événement de clic sur la carte
    map.on("click", function (e) {
      // Vérification si le clic est sur la couche du masque
      const featuresMasque = map.queryRenderedFeatures(e.point, {
        layers: ["masque-layer"],
      });

      if (featuresMasque.length > 0) {
        return;
      }

      // Vérification si le clic est sur la couche de Papi Zorn
      const featuresPapiZorn = map.queryRenderedFeatures(e.point, {
        layers: ["papizorn-layer"],
      });

      // Récupération des coordonnées du clic
      var coordinates = { lng: parseFloat(e.lngLat.lng.toFixed(5)), lat: parseFloat(e.lngLat.lat.toFixed(5)) };
      console.log(coordinates);

      const lat = coordinates.lat;
      const lon = coordinates.lng;

      Promise.all([
        recupererParcelle(lat, lon)
      ]).then((results) => {
        const cadastreData = results[0];
        console.log(cadastreData);
        console.log(geomToOdsPolygon(cadastreData.geo_shape))



        if (cadastreData.geo_shape) {
          map.getSource("parcel-source").setData(cadastreData.geo_shape);
        } else {
          map
            .getSource("parcel-source")
            .setData({ type: "FeatureCollection", features: [] });
        }



      })

    })
    // Fonction pour récupérer les données de la parcelle en utilisant l'API d'OpenDataSoft
    function recupererParcelle(lat, lng) {
      const cadApiUrl = `https://data.strasbourg.eu/api/records/1.0/search/?dataset=parcelles_cadastrales&q=&geofilter.distance=${lat}%2C${lng}%2C1`;

      return fetch(cadApiUrl)
        .then((response) => response.json())
        .then((data) => {
          if (data.records && data.records.length > 0) {
            const parcelleId = data.records[0].fields.id_parcellaire;
            const parcelleGeo = data.records[0].fields.geo_shape;
            return { id_parcellaire: parcelleId, geo_shape: parcelleGeo };
          } else {
            return "N/A";
          }
        })
        .catch((error) => {
          console.error(
            "Une erreur s'est produite lors de la récupération des données du cadastre :",
            error
          );
          return "N/A";
        });
    }

  </script>
</body>

</html>
